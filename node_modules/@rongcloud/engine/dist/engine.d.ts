
/**
 * 数据通道接口，为 long-polling 与 websocket 提供公共抽象
 */
declare abstract class ADataChannel {
    protected _watcher: IDataChannelWatcher;
    /**
     * 建立连接时，apiVersion 需符合 `/\d+(\.\d+){2}/` 规则，对于预发布版本号如 `3.1.0-alpha.1`，需解析定为 `3.1.0`
     * @param apiVersion
     */
    static matchVersion(apiVersion: string): string;
    /**
     * 通道所需的数据编解码器
     */
    readonly codec: DataCodec;
    connectedTime: number;
    userId: string;
    constructor(type: 'websocket' | 'comet', _watcher: IDataChannelWatcher);
    /**
     * 建立连接，连接成功则返回 Websocket 实例，否则返回连接错误码
     * @param appkey
     * @param token
     * @param hosts 服务器地址，不包含协议头，`hostname:port`
     * @param protocol 请求导航数据时使用的网络协议, /ping 与 websocket 需要继续遵循该协议
     * @param apiVersion - apiVersion 需符合 `/\d+(\.\d+){2}/` 规则，对于预发布版本号如 `3.1.0-alpha.1` 需认定为 `3.1.0`
     */
    abstract connect(appkey: string, token: string, host: string[], protocol: 'http' | 'https', apiVersion: string): Promise<ErrorCode>;
    /**
     * 只发送数据，无需响应
     */
    abstract sendOnly(writer: BaseWriter): void;
    /**
     *
     * @param writer
     * @param pbName 响应数据的 PB 定义
     * @param timeout 超时配置，单位 ms
     */
    abstract send<T>(writer: QueryWriter | PublishWriter, pbName?: string, option?: any, timeout?: number): IPromiseResult<T>;
    /**
     * 关闭数据通道，同时清空监听
     */
    abstract close(): void;
}

export declare class APIContext {
    private _runtime;
    private static _context?;
    static init(runtime: IRuntime, options: IAPIContextOption): APIContext;
    static destroy(): void;
    /**
     * 导航模块，用于连接前查找 CMP 地址
     */
    private readonly _navi;
    private _token;
    /**
     * 插件队列，用于逐一派发消息与信令
     */
    private _pluginContextQueue;
    private readonly _engine;
    /**
     * 核心库版本号，后期与 4.0 IM SDK 版本号保持一致
     */
    readonly coreVersion: string;
    readonly appkey: string;
    readonly apiVersion: string;
    private readonly _options;
    constructor(_runtime: IRuntime, options: IAPIContextOption);
    /**
     * 安装使用插件，并初始化插件实例
     * @param plugin
     * @param options
     */
    install<T, O>(plugin: IPluginGenerator<T, O>, options: O): T | null;
    private _connectionStatus;
    /**
     * 连接状态变更回调
     * @param message
     */
    private _connectionStatusListener;
    private _messageReceiver;
    /**
     * 聊天室相关信息监听
    */
    private _chatroomInfoListener;
    /**
     * 会话监听相关
    */
    private _conversationInfoListener;
    /**
     * 消息扩展监听相关
    */
    private _expansionInfoListener;
    /**
     * 业务层事件监听器挂载点
     */
    private _watcher;
    /**
     * 添加事件监听
     * @param options
     */
    assignWatcher(watcher: IWatcher): void;
    getConnectedTime(): number;
    getCurrentUserId(): string;
    getConnectionStatus(): ConnectionStatus;
    /**
     * 建立连接，连接失败则抛出异常，连接成功后返回用户 userId，否则返回相应的错误码
     * @param token
     * @param refreshNavi 是否需要重新请求导航，当值为 `false` 时，优先使用有效缓存导航，若缓存失效则重新获取导航
     */
    connect(token: string, refreshNavi?: boolean): Promise<IConnectResult>;
    getConnectTime(): IPromiseResult<number>;
    /**
     * 拉取实时配置 web 端需更新 voipCall 字段
     */
    private _pullUserSettings;
    disconnect(): Promise<void>;
    reconnect(): Promise<IConnectResult>;
    private _getTokenWithoutNavi;
    /**
     * 获取当前缓存的导航数据
     */
    getInfoFromCache(): INaviInfo | null;
    /**
     * 消息注册
     * @description 消息注册需在应用初始化完成前进行
     * @param objectName 消息类型，如：RC:TxtMsg
     * @param isPersited 是否存储
     * @param isCounted 是否技术
     * @param searchProps 搜索字段，只在搭配协议栈使用时有效
     */
    registerMessageType(objectName: string, isPersited: boolean, isCounted: boolean, searchProps?: string[]): void;
    /**
     * 发送消息
     * @param conversationType
     * @param targetId
     * @param objectName
     * @param content
     * @param options
     */
    sendMessage(conversationType: ConversationType, targetId: string, options: ISendMsgOptions): IPromiseResult<IReceivedMessage>;
    /**
     * 发送扩展消息
     * @param messageUId 消息 Id
     * @param keys 需要删除的 key
     * @param expansion 设置的扩展
    */
    sendExpansionMessage(options: ISendExMsgOptions): Promise<IAsyncRes<ErrorCode>>;
    /**
     * 反初始化，清空所有监听及计时器
     */
    private _destroy;
    /**
     * @param conversationType
     * @param targetId 会话 Id
     * @param timestamp 拉取时间戳
     * @param count 拉取条数
     * @param order 1 正序拉取，0 为倒序拉取
     */
    getHistoryMessage(conversationType: ConversationType, targetId: string, timestamp?: number, count?: number, order?: 0 | 1): IPromiseResult<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>;
    /**
     * 获取会话列表
     * @param count 指定获取数量, 不传则获取全部会话列表，默认 `300`
     */
    getConversationList(count?: number, conversationType?: ConversationType, startTime?: number, order?: 0 | 1): IPromiseResult<IReceivedConversation[]>;
    /**
     * 删除会话
     */
    removeConversation(conversationType: ConversationType, targetId: string): Promise<ErrorCode>;
    /**
     * 清除会话消息未读数
     */
    clearUnreadCount(conversationType: ConversationType, targetId: string): Promise<ErrorCode>;
    /**
     * 获取指定会话消息未读数
     */
    getUnreadCount(conversationType: ConversationType, targetId: string): IPromiseResult<number>;
    getTotalUnreadCount(): IPromiseResult<number>;
    setConversationStatus(conversationType: ConversationType, targetId: string, isTop?: boolean, notificationStatus?: 1 | 2): Promise<ErrorCode>;
    saveConversationMessageDraft(conversationType: ConversationType, targetId: string, draft: string): Promise<ErrorCode>;
    getConversationMessageDraft(conversationType: ConversationType, targetId: string): IPromiseResult<string>;
    clearConversationMessageDraft(conversationType: ConversationType, targetId: string): Promise<ErrorCode>;
    recallMessage(conversationType: ConversationType, targetId: string, messageUId: string, sentTime: number, user?: {
        [key: string]: string;
    }): IPromiseResult<IReceivedMessage>;
    /**
     * 删除远端消息
     * @param conversationType
     * @param targetId
     * @param list
     */
    deleteRemoteMessage(conversationType: ConversationType, targetId: string, list: {
        messageUId: string;
        sentTime: number;
        messageDirection: MessageDirection;
    }[]): Promise<ErrorCode>;
    /**
     * 根据时间戳删除指定时间之前的
     * @param conversationType
     * @param targetId
     * @param timestamp
     */
    deleteRemoteMessageByTimestamp(conversationType: ConversationType, targetId: string, timestamp: number): Promise<ErrorCode>;
    /**
     * 加入聊天室，若聊天室不存在则创建聊天室
     * @param roomId 聊天室房间 Id
     * @param count 进入聊天室成功后，自动拉取的历史消息数量，默认值为 `10`，最大有效值为 `50`，`-1` 为不拉取
     */
    joinChatroom(roomId: string, count?: number): Promise<ErrorCode>;
    /**
     * 加入聊天室，若聊天室不存在则抛出异常
     * @param roomId 聊天室房间 Id
     * @param count 进入聊天室成功后，自动拉取的历史消息数量，默认值为 `10`，最大有效值为 `50`，`-1` 为不拉取
     */
    joinExistChatroom(roomId: string, count?: number): Promise<ErrorCode>;
    /**
     * 退出聊天室
     * @param roomId
     */
    quitChatroom(roomId: string): Promise<ErrorCode>;
    /**
     * 获取聊天室房间数据
     * @description count 或 order 有一个为 0 时，只返回成员总数，不返回成员列表信息
     * @param roomId 聊天室 Id
     * @param count 获取房间人员列表数量，最大有效值 `20`，最小值未 `0`，默认为 0
     * @param order 人员排序方式，`1` 为正序，`2` 为倒序，默认为 0
     */
    getChatroomInfo(roomId: string, count?: number, order?: 0 | 1 | 2): IPromiseResult<IChatroomInfo>;
    /**
     * 在指定聊天室中设置自定义属性
     * @description 仅聊天室中不存在此属性或属性设置者为己方时可设置成功
     * @param roomId 聊天室房间 id
     * @param entry 属性信息
     */
    setChatroomEntry(roomId: string, entry: IChatroomEntry): Promise<ErrorCode>;
    /**
     * 在指定聊天室中强制增加 / 修改任意聊天室属性
     * @description 仅聊天室中不存在此属性或属性设置者为己方时可设置成功
     * @param roomId 聊天室房间 id
     * @param entry 属性信息
     */
    forceSetChatroomEntry(roomId: string, entry: IChatroomEntry): Promise<ErrorCode>;
    /**
     * 删除聊天室属性
     * @description 该方法仅限于删除自己设置的聊天室属性
     * @param roomId 聊天室房间 id
     * @param entry 要移除的属性信息
     */
    removeChatroomEntry(roomId: string, entry: IRemoveChatRoomEntryOption): Promise<ErrorCode>;
    /**
     * 强制删除任意聊天室属性
     * @description 该方法仅限于删除自己设置的聊天室属性
     * @param roomId 聊天室房间 id
     * @param entry 要移除的属性信息
     */
    forceRemoveChatroomEntry(roomId: string, entry: IRemoveChatRoomEntryOption): Promise<ErrorCode>;
    /**
     * 获取聊天室中的指定属性
     * @param roomId 聊天室房间 id
     * @param key 属性键名
     */
    getChatroomEntry(roomId: string, key: string): IPromiseResult<string | null>;
    /**
     * 获取聊天室内的所有属性
     * @param roomId 聊天室房间 id
     */
    getAllChatroomEntries(roomId: string): IPromiseResult<{
        [key: string]: string;
    }>;
    /**
     * 拉取聊天室内的历史消息
     * @param roomId
     * @param count 拉取消息条数, 有效值范围 `1 - 20`
     * @param order 获取顺序，默认值为 0。
     * * 0：降序，用于获取早于指定时间戳发送的消息
     * * 1：升序，用于获取晚于指定时间戳发送的消息
     * @param timestamp 指定拉取消息用到的时间戳。默认值为 `0`，表示按当前时间拉取
     */
    getChatRoomHistoryMessages(roomId: string, count?: number, order?: 0 | 1, timestamp?: number): IPromiseResult<{
        list: IReceivedMessage[];
        hasMore: boolean;
    }>;
    /**
     * 获取 七牛、百度上传认证信息
     * @param fileType 文件类型
     * @param fileName 文件名
    */
    getFileToken(fileType: FileType, fileName?: string): Promise<IUploadAuth & {
        bos: string;
        qiniu: string;
    }>;
    /**
     * 获取 七牛、百度上传成功可下载的 URL
     * @param fileType 文件类型
     * @param fileName 文件名
     * @param originName 文件源名
     * @param uploadRes 插件上传返回的结果。降级百度上传后，用户传入返回结果，再把结果里的下载地址返回给用户，保证兼容之前结果获取
    */
    getFileUrl(fileType: FileType, fileName?: string, originName?: string, uploadRes?: {
        isBosRes: boolean;
        downloadUrl: string;
    }): Promise<{
        downloadUrl: string;
    }>;
    /**
     * 加入房间
     * @param roomId
     * @param mode 房间模式：直播 or 会议
     * @param mediaType 直播房间模式下的媒体资源类型
     */
    joinRTCRoom(roomId: string, mode: RTCMode, mediaType?: number): IPromiseResult<IJoinRTCRoomData>;
    quitRTCRoom(roomId: string): Promise<ErrorCode>;
    rtcPing(roomId: string, mode: number, mediaType?: number): Promise<ErrorCode>;
    getRTCRoomInfo(roomId: string): IPromiseResult<IRTCRoomInfo>;
    getRTCUserInfoList(roomId: string): IPromiseResult<IRTCUsers>;
    getRTCUserInfo(roomId: string): IPromiseResult<unknown>;
    setRTCUserInfo(roomId: string, key: string, value: string): Promise<ErrorCode>;
    removeRTCUserInfo(roomId: string, keys: string[]): Promise<ErrorCode>;
    setRTCData(roomId: string, key: string, value: string, isInner: boolean, apiType: RTCApiType, message?: any): Promise<ErrorCode>;
    setRTCTotalRes(roomId: string, message: {
        name: string;
        content: string;
    }, valueInfo: string, objectName: string): Promise<ErrorCode>;
    getRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType): IPromiseResult<KVString>;
    removeRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType, message: Object): Promise<ErrorCode>;
    setRTCOutData(roomId: string, rtcData: unknown, type: number, message: unknown): Promise<ErrorCode>;
    getRTCOutData(roomId: string, userIds: string[]): IPromiseResult<unknown>;
    getRTCToken(roomId: string, mode: number, broadcastType?: number): IPromiseResult<IRtcTokenData>;
    setRTCState(roomId: string, report: string): Promise<ErrorCode>;
    getRTCUserList(roomId: string): IPromiseResult<IRTCUsers>;
}

export declare const appendUrl: (url: string, query?: {
    [key: string]: string | number | null;
} | undefined) => string;

export declare class AppStorage {
    private _cache;
    private _storageKey;
    private _rootStorage;
    constructor(runtime: IRuntime, suffix?: string);
    _get(): any;
    _set(cache: {
        [id: string]: any;
    }): void;
    set(key: string, value: any): void;
    remove(key: string): void;
    clear(): void;
    get(key: string): any;
    getKeys(): string[];
    getValues(): any;
}

/**
 * 参数校验，该方法用于对业务层入参数据检查，及时抛出异常通知业务层进行修改
 * @description
 * 1. 必填参数，value 需符合 validator 验证规，否则抛出异常
 * 2. 非必填参数，value 可为 undefined | null 或符合 validator 规则
 * @param key 字段名，仅用于验证失败时给出提示信息
 * @param value 待验证的值
 * @param validator 期望类型或校验规则函数，若使用规则函数
 * @param required 是否为必填参数，默认为 `false`
 */
export declare const assert: (key: string, value: any, validator: AssertRules | ((value: any) => boolean), required?: boolean) => void;

/**
 * 预定义的验证规则，只包含`值类型`数据验证
 * 引用类型数据需使用自定义 validator 校验函数进行校验
 */
export declare enum AssertRules {
    /**
     * 类型为字符串，且长度大于 0
     */
    STRING = 0,
    /**
     * 类型仅为 String
    */
    ONLY_STRING = 1,
    /**
     * 类型为数字
     */
    NUMBER = 2,
    /**
     * 类型为布尔值
     */
    BOOLEAN = 3,
    /**
     * 类型为对象
    */
    OBJECT = 4,
    /**
     * 类型为数组
    */
    ARRAY = 5,
    /**
     * 类型为 callback 回调对象，包含 callback.onSuccess、callback.onError
    */
    CALLBACK = 6
}

/**
 * @description
 * 与 Server 交互的信令封装
*/
/**
 * @description
 * 读数据处理基类
*/
declare class BaseReader {
    readonly header: Header;
    protected _name: string | null;
    lengthSize: number;
    messageId: number;
    timestamp: number;
    syncMsg: boolean;
    identifier: string;
    constructor(header: Header);
    getIdentifier(): string | number;
    read(stream: RongStreamReader, length: number): void;
    readMessage(stream: RongStreamReader, length?: number): {
        stream: RongStreamReader;
        length: number | undefined;
    };
}

/**
 * @description
 * 写数据处理基类
 */
declare abstract class BaseWriter {
    private _header;
    lengthSize: number;
    data: any;
    messageId: number;
    topic: string;
    targetId: string;
    identifier: string;
    constructor(headerType: OperationType);
    getIdentifier(): string | number;
    write(stream: RongStreamWriter): void;
    abstract writeMessage(stream: RongStreamWriter): void;
    setHeaderQos(qos: number): void;
    getHeaderFlag(): number;
    getLengthSize(): number;
    getBufferData(): Int8Array;
    getCometData(): string;
}

/**
 * CallLib 流程消息
 */
export declare const CallLibMsgType: {
    'RC:VCAccept': string;
    'RC:VCRinging': string;
    'RC:VCSummary': string;
    'RC:VCHangup': string;
    'RC:VCInvite': string;
    'RC:VCModifyMedia': string;
    'RC:VCModifyMem': string;
};

/**
 *  聊天室 kv 存储操作类型. 对方操作, 己方收到消息(RC:chrmKVNotiMsg)中会带入此值. 根据此值判断是删除还是更新
*/
declare enum ChatroomEntryType {
    UPDATE = 1,
    DELETE = 2
}

export declare class CometChannel extends ADataChannel {
    private _runtime;
    userId: string;
    private _pid;
    private _sessionid;
    private _domain;
    private _isDisconnected;
    private _messageIds;
    private _syncMessageIds;
    private _protocol;
    connectedTime: number;
    constructor(_runtime: IRuntime, watcher: IDataChannelWatcher);
    /**
     * 长轮询结果处理
     * @param data
     */
    handleCometRes(res: IResponse): boolean;
    /**
     * 长轮询心跳
     */
    _startPullSignal(protocol: 'http' | 'https'): Promise<void>;
    connect(appkey: string, token: string, hosts: string[], protocol: 'http' | 'https', apiVersion: string): Promise<ErrorCode>;
    private _idCount;
    private _generateMessageId;
    sendCometData(writer: BaseWriter, timeout?: number): Promise<void>;
    sendOnly(writer: BaseWriter): void;
    send(writer: QueryWriter | PublishWriter, respPBName?: string, option?: any, timeout?: number): Promise<IAsyncRes>;
    close(): void;
}

/**
 * 连接状态
 */
export declare enum ConnectionStatus {
    /**
     * 连接成功。
     */
    CONNECTED = 0,
    /**
     * 连接中。
     */
    CONNECTING = 1,
    /**
     * 正常断开连接。
     */
    DISCONNECTED = 2,
    /**
     * 网络不可用。
     */
    NETWORK_UNAVAILABLE = 3,
    /**
     * 连接关闭。
     */
    CONNECTION_CLOSED = 4,
    /**
     * 用户账户在其他设备登录，本机会被踢掉线。
     */
    KICKED_OFFLINE_BY_OTHER_CLIENT = 6,
    /**
     * websocket 连接失败
     */
    WEBSOCKET_UNAVAILABLE = 7,
    /**
     * websocket 报错
     */
    WEBSOCKET_ERROR = 8,
    /**
     * 用户被封禁
     */
    BLOCKED = 9,
    /**
     * 域名错误
     */
    DOMAIN_INCORRECT = 12,
    /**
     * appkey 不正确
     */
    APPKEY_IS_FAKE = 20,
    /**
     * 互踢次数过多（`count > 5`），此时可能出现：在其它他设备登陆有 reconnect 逻辑
     */
    ULTRALIMIT = 1101,
    /**
     * 开始请求导航
     */
    REQUEST_NAVI = 201,
    /**
     * 请求导航结束
     */
    RESPONSE_NAVI = 202,
    /**
     *  请求导航失败
     */
    RESPONSE_NAVI_ERROR = 203,
    /**
     *  请求导航超时
     */
    RESPONSE_NAVI_TIMEOUT = 204
}

/**
 * CMP/Comet 服务连接应答码
 */
export declare const ConnectResultCode: {
    /**
     * 连接成功
     */
    ACCEPTED: number;
    /**
     * 协议版本不匹配
     * @description 暂未使用
     */
    UNACCEPTABLE_PROTOCOL_VERSION: number;
    /**
     * 客户端（移动端 TCP 连接建立时）`info` 字段格式错误
     * @description 格式：`{平台类型}-{设备信息}-{sdk版本}`。
     * 其中设备信息为：{手机类型}{手机型号}{网络类型，4G/WIFI}{运营商标识, 移动/电信/联通}
     */
    IDENTIFIER_REJECTED: number;
    /**
     * 不支持的平台类型，一般小程序或 PC 未开通
     */
    SERVER_UNAVAILABLE: number;
    /**
     * Token无法解析，或Token已过期
     */
    TOKEN_INCORRECT: number;
    /**
     * 防黑产规则相关应答
     */
    NOT_AUTHORIZED: number;
    /**
     * 服务重定向，一般服务扩缩容时，落点已经改变，此时 userId 链接到旧的节点时，会触发该错误。
     * 客户端收到该应答后须重新访问导航，重新获取 CMP 地址
     */
    REDIRECT: number;
    /**
     * 暂未使用
     */
    PACKAGE_ERROR: number;
    /**
     * 该 AppKey 已经封禁或删除
     */
    APP_BLOCK_OR_DELETE: number;
    /**
     * 该用户 ID 已经被封禁
     */
    BLOCK: number;
    /**
     * Token 已过期，暂未使用
     */
    TOKEN_EXPIRE: number;
    /**
     * Token 中携带 deviceId 时，检测 Token 中 deviceId 与链接设备 deviceId 不一致
     */
    DEVICE_ERROR: number;
    /**
     * Web 端设置安全域名后，连接端域名不在安全域名范围内
     */
    HOSTNAME_ERROR: number;
    /**
     * 开启`禁止把已在线客户端踢下线`开关后，该错误码标识已有同类型端在线，禁止链接
     */
    HASOHTERSAMECLIENTONLINE: number;
};

/**
 * 会话类型
 */
export declare enum ConversationType {
    /**
     * 无类型
     */
    NONE = 0,
    /**
     * 单聊
     */
    PRIVATE = 1,
    /**
     * 讨论组
     */
    DISCUSSION = 2,
    /**
     * 群组聊天
     */
    GROUP = 3,
    /**
     * 聊天室会话
     */
    CHATROOM = 4,
    /**
     * 客服会话
     */
    CUSTOMER_SERVICE = 5,
    /**
     * 系统消息
     */
    SYSTEM = 6,
    /**
     * 默认关注的公众号会话类型（MC)
     */
    APP_PUBLIC_SERVICE = 7,
    /**
     * 需手动关注的公众号会话类型（MP)
     */
    PUBLIC_SERVICE = 8,
    /**
     * RTCLib 特有的会话类型
     */
    RTC_ROOM = 12
}

/**
 * 序列化、反序列化数据通道
*/
declare class DataCodec {
    private _codec;
    private _connectType;
    constructor(connectType: 'websocket' | 'comet');
    /**
     * PB 数据 转为 rmtp 数据 反序列化 通用数据
     * 根据解析的 PBName 分配解码方法. 如果没有单独的解码方法定义. 直接返回 pb 解析后的结果
    */
    decodeByPBName(data: any, pbName: string, option?: any): any;
    private _readBytes;
    /**
     * ====== 以下为 rmtp 数据 反序列化为 可用数据 ======
     */
    private _formatBytes;
    /**
     * 格式化多端同步消息
    */
    private _formatSyncMessages;
    /**
     * 格式化接收消息
    */
    private _formatReceivedMessage;
    /**
     * 格式化发送消息
    */
    private _formatSentMessage;
    /**
     * 格式化历史消息
    */
    private _formatHistoryMessages;
    /**
     * 格式化会话列表
    */
    private _formatConversationList;
    /**
     * 格式化聊天室信息
    */
    private _formatChatRoomInfos;
    /**
     * 格式化 聊天室 KV 列表
    */
    private _formatChatRoomKVList;
    /**
     * 格式化 用户设置
    */
    private _formatUserSetting;
    /**
     * 格式化 会话状态 置顶、免打扰）
    */
    private _formatConversationStatus;
    /**
     * 格式化 RTC 用户列表
    */
    private _formatRTCUserList;
    /**
      * 格式化 RTC 数据
    */
    private _formatRTCData;
    /**
      * 格式化 RTC 房间信息
    */
    private _formatRTCRoomInfo;
    /**
     * ===== 以下为通用数据 序列化为 PB 数据 =====
     * Engine Index 调用处理数据
    */
    /**
     * ? 待补全注释
    */
    encodeServerConfParams(): any[];
    /**
     * 上行消息基础配置
    */
    private _getUpMsgModule;
    /**
     * 序列化上行消息
    */
    encodeUpMsg(conversation: IConversationOption, option: ISendMsgOptions): any[];
    /**
     * 序列化拉取多端消息
    */
    encodeSyncMsg(syncMsgArgs: ISyncMsgArgs): any[];
    /**
     * 序列化拉取聊天室消息
    */
    encodeChrmSyncMsg(time: number, count: number): any[];
    /**
     * 序列化历史消息
    */
    encodeGetHistoryMsg(targetId: string, option: IGetMsgOption): any[];
    /**
     * 序列化会话列表
    */
    encodeGetConversationList(option: IGetConversationListOption): any[];
    /**
     * 旧会话列表. 获取、删除都调用此方法
    */
    encodeOldConversationList(option: IGetConversationListOption): any[];
    /**
     * 旧会话列表删除
    */
    encodeRemoveConversationList(conversationList: IConversationOption[]): any[];
    /**
     * 批量删除消息通过消息 ID
    */
    encodeDeleteMessages(conversationType: ConversationType, targetId: string, list: {
        messageUId: string;
        sentTime: number;
        messageDirection: MessageDirection;
    }[]): any[];
    /**
     * 批量删除消息通过时间
    */
    encodeClearMessages(targetId: string, timestamp: number): any[];
    /**
     * 未读数清除
    */
    encodeClearUnreadCount(conversation: IConversationOption, option: IClearMsgOption): any[];
    /**
     * 加入退出聊天室
    */
    encodeJoinOrQuitChatRoom(): any[];
    /**
     * 获取聊天室信息
     * @param count 获取人数
     * @param order 排序方式
    */
    encodeGetChatRoomInfo(count: number, order: number): any[];
    /**
     * 上传文件认证信息获取
    */
    encodeGetFileToken(fileType: number, fileName: string): any;
    /**
      * 获取七牛上传url
    */
    encodeGetFileUrl(fileType: number, fileName?: string, originName?: string): any;
    /**
      * 聊天室 KV 存储
    */
    encodeModifyChatRoomKV(chrmId: string, entry: IChrmKVEntry, currentUserId: string): any;
    /**
      * KV 存储拉取
    */
    encodePullChatRoomKV(time: number): any;
    /**
      * 用户实时配置更新
    */
    encodePullUserSetting(version: number): any;
    /**
      * 获取会话状态 (置顶、免打扰)
    */
    encodeGetConversationStatus(time: number): any;
    /**
      * 设置会话状态 (置顶、免打扰)
    */
    encodeSetConversationStatus(statusList: Array<IServerConversationStatus>): any;
    /**
     * ============ 以下为 RTC 相关 ============
     */
    /**
     * 加入 RTC 房间
     */
    encodeJoinRTCRoom(mode: RTCMode, broadcastType?: number): any[];
    /**
     * 退出 RTC 房间
    */
    encodeQuitRTCRoom(): any[];
    /**
     * 房间数据
    */
    encodeSetRTCData(key: string, value: string, isInner: boolean, apiType: RTCApiType, message: any): any;
    /**
     * 全量 URI
    */
    encodeUserSetRTCData(message: any, valueInfo: string, objectName: string): any;
    /**
     * 待完善注释
    */
    encodeGetRTCData(keys: Array<string>, isInner: boolean, apiType: RTCApiType): any;
    /**
     * 待完善注释
    */
    encodeRemoveRTCData(keys: Array<string>, isInner: boolean, apiType: RTCApiType, message: any): any;
    /**
     * 待完善注释
    */
    encodeSetRTCOutData(data: any, type: number, message: any): any;
    /**
     * 待完善注释
    */
    ecnodeGetRTCOutData(userIds: string[]): any;
    encodeSetRTCState(report: string): any;
    /**
     * 待完善注释
    */
    encodeGetRTCRoomInfo(): any;
    /**
     * 待完善注释
    */
    encodeSetRTCUserInfo(key: string, value: string): any;
    /**
     * 待完善注释
    */
    encodeRemoveRTCUserInfo(keys: string[]): any;
}

/**
 * TODO: 确定对外暴露的必要性
 * @deprecated
 */
export declare const DelayTimer: {
    _delayTime: number;
    /**
     * 方法并未引用，getTimer 实际返回值始终为 Date.now()
     * @deprecated
     */
    setTime: (time: number) => void;
    getTime: () => number;
};

export declare enum ErrorCode {
    /** 超时 */
    TIMEOUT = -1,
    /**
     * 未知原因失败。
     */
    UNKNOWN = -2,
    /** 参数错误 */
    PARAMETER_ERROR = -3,
    /**
     * 成功
     */
    SUCCESS = 0,
    RC_MSG_UNAUTHORIZED = 20406,
    /**
     * 群组 Id 无效
     */
    RC_DISCUSSION_GROUP_ID_INVALID = 20407,
    /**
     * 发送频率过快
     */
    SEND_FREQUENCY_TOO_FAST = 20604,
    /**
     * 不在讨论组。
     */
    NOT_IN_DISCUSSION = 21406,
    /**
     * 群组被禁言
     */
    FORBIDDEN_IN_GROUP = 22408,
    RECALL_MESSAGE = 25101,
    /**
     * 不在群组。
     */
    NOT_IN_GROUP = 22406,
    /**
     * 不在聊天室。
     */
    NOT_IN_CHATROOM = 23406,
    /**
     *聊天室被禁言
     */
    FORBIDDEN_IN_CHATROOM = 23408,
    /**
     * 聊天室中成员被踢出
     */
    RC_CHATROOM_USER_KICKED = 23409,
    /**
     * 聊天室不存在
     */
    RC_CHATROOM_NOT_EXIST = 23410,
    /**
     * 聊天室成员已满
     */
    RC_CHATROOM_IS_FULL = 23411,
    /**
     * 获取聊天室信息参数无效
     */
    RC_CHATROOM_PATAMETER_INVALID = 23412,
    /**
     * 聊天室异常
     */
    CHATROOM_GET_HISTORYMSG_ERROR = 23413,
    /**
     * 没有打开聊天室消息存储
     */
    CHATROOM_NOT_OPEN_HISTORYMSG_STORE = 23414,
    /**
     * 聊天室 KV 设置超出最大值(已满, 默认最多设置 100 个)
     */
    CHATROOM_KV_EXCEED = 23423,
    /**
     * 聊天室 KV 设置失败(kv 已存在, 需覆盖设置)
     */
    CHATROOM_KV_OVERWRITE_INVALID = 23424,
    /**
     * 聊天室 KV 存储功能没有开通
     */
    CHATROOM_KV_STORE_NOT_OPEN = 23426,
    /**
     * 聊天室Key不存在
     */
    CHATROOM_KEY_NOT_EXIST = 23427,
    /**
     * 敏感词屏蔽
     */
    SENSITIVE_SHIELD = 21501,
    SENSITIVE_REPLACE = 21502,
    /**
     * 加入讨论失败
     */
    JOIN_IN_DISCUSSION = 21407,
    /**
     * 创建讨论组失败
     */
    CREATE_DISCUSSION = 21408,
    /**
     * 设置讨论组邀请状态失败
     */
    INVITE_DICUSSION = 21409,
    /**
     *获取用户失败
     */
    GET_USERINFO_ERROR = 23407,
    /**
     * 在黑名单中。
     */
    REJECTED_BY_BLACKLIST = 405,
    /**
     * 通信过程中，当前 Socket 不存在。
     */
    RC_NET_CHANNEL_INVALID = 30001,
    /**
     * Socket 连接不可用。
     */
    RC_NET_UNAVAILABLE = 30002,
    /**
     * 通信超时。
     */
    RC_MSG_RESP_TIMEOUT = 30003,
    /**
     * 导航操作时，Http 请求失败。
     */
    RC_HTTP_SEND_FAIL = 30004,
    /**
     * HTTP 请求失败。
     */
    RC_HTTP_REQ_TIMEOUT = 30005,
    /**
     * HTTP 接收失败。
     */
    RC_HTTP_RECV_FAIL = 30006,
    /**
     * 导航操作的 HTTP 请求，返回不是200。
     */
    RC_NAVI_RESOURCE_ERROR = 30007,
    /**
     * 导航数据解析后，其中不存在有效数据。
     */
    RC_NODE_NOT_FOUND = 30008,
    /**
     * 导航数据解析后，其中不存在有效 IP 地址。
     */
    RC_DOMAIN_NOT_RESOLVE = 30009,
    /**
     * 创建 Socket 失败。
     */
    RC_SOCKET_NOT_CREATED = 30010,
    /**
     * Socket 被断开。
     */
    RC_SOCKET_DISCONNECTED = 30011,
    /**
     * PING 操作失败。
     */
    RC_PING_SEND_FAIL = 30012,
    /**
     * PING 超时。
     */
    RC_PONG_RECV_FAIL = 30013,
    /**
     * 消息发送失败。
     */
    RC_MSG_SEND_FAIL = 30014,
    /**
     * JSON 后的消息体超限, 目前最大 128kb
     */
    RC_MSG_CONTENT_EXCEED_LIMIT = 30016,
    /**
     * 做 connect 连接时，收到的 ACK 超时。
     */
    RC_CONN_ACK_TIMEOUT = 31000,
    /**
     * 参数错误。
     */
    RC_CONN_PROTO_VERSION_ERROR = 31001,
    /**
     * 参数错误，App Id 错误。
     */
    RC_CONN_ID_REJECT = 31002,
    /**
     * 服务器不可用。
     */
    RC_CONN_SERVER_UNAVAILABLE = 31003,
    /**
     * Token 错误。
     */
    RC_CONN_USER_OR_PASSWD_ERROR = 31004,
    /**
     * websocket 鉴权失败，通常为连接后未及时发送 Ping 或接收到 Pong
     */
    RC_CONN_NOT_AUTHRORIZED = 31005,
    /**
     * 重定向，地址错误。
     */
    RC_CONN_REDIRECTED = 31006,
    /**
     * NAME 与后台注册信息不一致。
     */
    RC_CONN_PACKAGE_NAME_INVALID = 31007,
    /**
     * APP 被屏蔽、删除或不存在。
     */
    RC_CONN_APP_BLOCKED_OR_DELETED = 31008,
    /**
     * 用户被屏蔽。
     */
    RC_CONN_USER_BLOCKED = 31009,
    /**
     * Disconnect，由服务器返回，比如用户互踢。
     */
    RC_DISCONN_KICK = 31010,
    /**
     * Disconnect，由服务器返回，比如用户互踢。
     */
    RC_DISCONN_EXCEPTION = 31011,
    /**
     * 协议层内部错误。query，上传下载过程中数据错误。
     */
    RC_QUERY_ACK_NO_DATA = 32001,
    /**
     * 协议层内部错误。
     */
    RC_MSG_DATA_INCOMPLETE = 32002,
    /**
     * 未调用 init 初始化函数。
     */
    BIZ_ERROR_CLIENT_NOT_INIT = 33001,
    /**
     * 数据库初始化失败。
     */
    BIZ_ERROR_DATABASE_ERROR = 33002,
    /**
     * 传入参数无效。
     */
    BIZ_ERROR_INVALID_PARAMETER = 33003,
    /**
     * 通道无效。
     */
    BIZ_ERROR_NO_CHANNEL = 33004,
    /**
     * 重新连接成功。
     */
    BIZ_ERROR_RECONNECT_SUCCESS = 33005,
    /**
     * 连接中，再调用 connect 被拒绝。
     */
    BIZ_ERROR_CONNECTING = 33006,
    /**
     * 消息漫游服务未开通
     */
    MSG_ROAMING_SERVICE_UNAVAILABLE = 33007,
    MSG_INSERT_ERROR = 33008,
    MSG_DEL_ERROR = 33009,
    /**
     * 删除会话失败
     */
    CONVER_REMOVE_ERROR = 34001,
    /**
     *拉取历史消息
     */
    CONVER_GETLIST_ERROR = 34002,
    /**
     * 会话指定异常
     */
    CONVER_SETOP_ERROR = 34003,
    /**
     * 获取会话未读消息总数失败
     */
    CONVER_TOTAL_UNREAD_ERROR = 34004,
    /**
     * 获取指定会话类型未读消息数异常
     */
    CONVER_TYPE_UNREAD_ERROR = 34005,
    /**
     * 获取指定用户ID&会话类型未读消息数异常
     */
    CONVER_ID_TYPE_UNREAD_ERROR = 34006,
    CONVER_CLEAR_ERROR = 34007,
    /**
     * 扩展存储 key value 超出限制 (错误码与移动端对齐)
    */
    EXPANSION_LIMIT_EXCEET = 34010,
    /**
     * 消息不支持扩展 (错误码与移动端对齐)
    */
    MESSAGE_KV_NOT_SUPPORT = 34008,
    CLEAR_HIS_TIME_ERROR = 34011,
    CONVER_GET_ERROR = 34009,
    /**
     * 群组信息异常
     */
    GROUP_SYNC_ERROR = 35001,
    /**
     * 匹配群信息异常
     */
    GROUP_MATCH_ERROR = 35002,
    /**
     * 加入聊天室Id为空
     */
    CHATROOM_ID_ISNULL = 36001,
    /**
     * 加入聊天室失败
     */
    CHARTOOM_JOIN_ERROR = 36002,
    /**
     * 拉取聊天室历史消息失败
     */
    CHATROOM_HISMESSAGE_ERROR = 36003,
    /**
     * 聊天室 kv 未找到
     */
    CHATROOM_KV_NOT_FOUND = 36004,
    /**
     * 加入黑名单异常
     */
    BLACK_ADD_ERROR = 37001,
    /**
     * 获得指定人员再黑名单中的状态异常
     */
    BLACK_GETSTATUS_ERROR = 37002,
    /**
     * 移除黑名单异常
     */
    BLACK_REMOVE_ERROR = 37003,
    /**
     * 获取草稿失败
     */
    DRAF_GET_ERROR = 38001,
    /**
     * 保存草稿失败
     */
    DRAF_SAVE_ERROR = 38002,
    /**
     * 删除草稿失败
     */
    DRAF_REMOVE_ERROR = 38003,
    /**
     * 关注公众号失败
     */
    SUBSCRIBE_ERROR = 39001,
    /**
     * 关注公众号失败
     */
    QNTKN_FILETYPE_ERROR = 41001,
    /**
     * 获取七牛token失败
     */
    QNTKN_GET_ERROR = 41002,
    /**
     * cookie被禁用
     */
    COOKIE_ENABLE = 51001,
    GET_MESSAGE_BY_ID_ERROR = 61001,
    HAVNODEVICEID = 24001,
    DEVICEIDISHAVE = 24002,
    FEILD = 24009,
    VOIPISNULL = 24013,
    NOENGINETYPE = 24010,
    NULLCHANNELNAME = 24011,
    VOIPDYANMICERROR = 24012,
    NOVOIP = 24014,
    INTERNALERRROR = 24015,
    VOIPCLOSE = 24016,
    CLOSE_BEFORE_OPEN = 51001,
    ALREADY_IN_USE = 51002,
    INVALID_CHANNEL_NAME = 51003,
    VIDEO_CONTAINER_IS_NULL = 51004,
    /**
     * 删除消息数组长度为 0 .
     */
    DELETE_MESSAGE_ID_IS_NULL = 61001,
    /**
     * 己方取消已发出的通话请求
     */
    CANCEL = 1,
    /**
     * 己方拒绝收到的通话请求
     */
    REJECT = 2,
    /**
     * 己方挂断
     */
    HANGUP = 3,
    /**
     * 己方忙碌
     */
    BUSYLINE = 4,
    /**
     * 己方未接听
     */
    NO_RESPONSE = 5,
    /**
     * 己方不支持当前引擎
     */
    ENGINE_UN_SUPPORTED = 6,
    /**
     * 己方网络出错
     */
    NETWORK_ERROR = 7,
    /**
     * 对方取消已发出的通话请求
     */
    REMOTE_CANCEL = 11,
    /**
     * 对方拒绝收到的通话请求
     */
    REMOTE_REJECT = 12,
    /**
     * 通话过程对方挂断
     */
    REMOTE_HANGUP = 13,
    /**
     * 对方忙碌
     */
    REMOTE_BUSYLINE = 14,
    /**
     * 对方未接听
     */
    REMOTE_NO_RESPONSE = 15,
    /**
     * 对方网络错误
     */
    REMOTE_ENGINE_UN_SUPPORTED = 16,
    /**
     * 对方网络错误
     */
    REMOTE_NETWORK_ERROR = 17,
    /**
     * VoIP 不可用
     */
    VOIP_NOT_AVALIABLE = 18
}

/**
 * 文件类型
 */
export declare enum FileType {
    /**
     * 图片文件
     */
    IMAGE = 1,
    /**
     * 声音文件
     */
    AUDIO = 2,
    /**
     * 视频文件
     */
    VIDEO = 3,
    /**
     * 非媒体文件
     */
    FILE = 4
}

/**
 * @todo 后期禁用此方法，容易滥用，且会丢失上下文的数据类型跟踪
 * @deprecated
 * @param source
 * @param event
 * @param options
 */
export declare const forEach: (source: any, event: Function, options?: any) => void;

export declare const getUploadFileName: (type: number, fileName?: string | undefined) => string;

/**
 * @todo 注释补全
 * @description
 * Header 处理
*/
declare class Header {
    readonly type: OperationType;
    private readonly _retain;
    qos: QOS;
    private readonly _dup;
    readonly syncMsg: boolean;
    constructor(type: OperationType, retain?: boolean, qos?: QOS, dup?: boolean);
    encode(): number;
}

export declare enum HttpMethod {
    GET = "GET",
    POST = "POST"
}

export declare interface IAPIContextOption {
    /**
     * 应用 appkey
     */
    appkey: string;
    /**
     * IMLib 版本号
     */
    apiVersion: string;
    /**
     * 自定义导航地址:
     * 1. 私有云环境下该值为必填项
     * 2. 当存在自定义导航地址时，SDK 内部默认地址将无效
     * 3. 当存在自定义导航地址时，地址 url 中需包含 http/https 协议头，否则视为无效值
     * 4. 建立 ws/wss 连接前的 ping 接口使用的协议与导航 url 中的协议相同
     * 5. 建立 websocket 建立连接时将根据 ping 接口使用的 http/https 协议来确定使用 ws/wss 协议
     * 6. 动态导航使用的协议头将与自定义导航地址相同
     * 7. 公有云默认使用 https 协议
     */
    navigators: string[];
    /**
     * c++ 协议栈实例
     */
    cppProtocol?: unknown;
    /**
     * 小程序的 CMP 代理地址
     */
    miniCMPProxy: string[];
    /**
     * 指定默认使用的连接类型
     */
    connectionType: 'websocket' | 'comet';
    /**
     * 私有云标识
     */
    isEnterPrise: boolean;
}

export declare interface IAsyncRes<T = any> {
    /**
     * Promise 执行结果
     */
    code: ErrorCode;
    /**
     * 结果数据
     */
    data?: T;
}

export declare interface IChatroomEntry {
    /**
     * 属性名称, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
     */
    key: string;
    /**
     * 属性对应的值, 最大长度 4096 字符
     */
    value: string;
    /**
     * 设置成功后是否发送通知消息
     */
    isSendNotification?: boolean;
    /**
     * RC:chrmKVNotiMsg 消息中携带的附加信息
     */
    notificationExtra?: string;
    /**
     * 用户退出聊天室时是否清除此属性
     */
    isAutoDelete?: boolean;
}

declare interface IChatroomEntryListenerData {
    /**
     * 更新的键
    */
    key: string;
    /**
     * 更新的值
    */
    value: string;
    /**
     * 更新的时间
    */
    timestamp: number;
    /**
     * 更新的聊天室 ID
    */
    chatroomId: string;
    /**
     * 更新类型
    */
    type: ChatroomEntryType;
}

export declare interface IChatroomInfo {
    /**
     * 成员列表
     * @todo 需确认数组元素的数据结构
     */
    userInfos: IChatroomUser[];
    /**
     * 房间内总人数
     */
    userCount: number;
}

export declare type IChatroomListener = (state: IChatroomListenerData) => void;

/**
 * 聊天室信息
*/
declare interface IChatroomListenerData {
    /**
     * SDK 内部重连聊天室信息
    */
    rejoinedRoom: IChatroomRejoinedInfo;
    /**
     * 监听到的聊天室 KV 更新
    */
    updatedEntries: IChatroomEntryListenerData[];
}

declare interface IChatroomRejoinedFailed {
    /**
     * 自动重新加入的聊天室 ID
    */
    chatroomId: string;
    /**
     * 自动重新加入失败的 code
    */
    errorCode: number;
}

declare type IChatroomRejoinedInfo = IChatroomRejoinedFailed | IChatroomRejoinedSuccessed;

declare interface IChatroomRejoinedSuccessed {
    /**
     * 自动重新加入的聊天室 ID
    */
    chatroomId: string;
    /**
     * 自动重新加入的聊天室拉取消息的数量
    */
    count: number;
}

declare interface IChatroomUser {
    /**
     * 用户 id
     */
    id: string;
    /**
     * 加入聊天室的时间
     */
    time: number;
}

declare interface IChrmKVEntry {
    key: string;
    value?: string;
    isSendNotification?: boolean;
    notificationExtra?: string;
    isOverwrite?: boolean;
    isAutoDelete?: boolean;
    timestamp?: number;
    userId?: string;
    type?: number;
    isDeleted?: boolean;
}

declare interface IClearMsgOption {
    timestamp?: number;
}

export declare type IConnectionStatusListener = (status: ConnectionStatus) => void;

export declare interface IConnectResult {
    /**
     * 连接错误码
     */
    code: ErrorCode;
    /**
     * 导航获取成功后即可有相应的值，在导航数据获取完成之前该值为 undefined
     */
    userId?: string;
}

export declare interface IConversationOption {
    type: ConversationType;
    targetId: string;
}

export declare type IConversationStateListener = (conversation: IUpdatedConversation[]) => void;

export declare interface IDataChannelWatcher {
    /**
     * 连接状态变更通知
     */
    status: (status: ConnectionStatus) => void;
    /**
     * 业务信令通知
     * @params signal
     * @params ack 当接收到的数据为多端同步消息时，ack 值为 PubAck，否则为 undefined
     */
    signal: (signal: PublishReader, ack?: PubAckReader) => void;
}

declare interface IDeletedExpansion {
    deletedKeys: string[];
    messageUId: string;
}

export declare type IExpansionListener = (data: IExpansionListenerData) => void;

export declare interface IExpansionListenerData {
    updatedExpansion?: IUpdatedExpansion;
    deletedExpansion?: IDeletedExpansion;
}

export declare interface IExpansionMsgContent {
    /**
     * 消息扩展的对象
    */
    put?: {
        [key: string]: string;
    };
    /**
     * 删除的 keys
    */
    del?: string[];
    /**
     * messageUId
    */
    mid: string;
    /**
     * 是否删除所有, 有效值：0、1 . ( 后续如有需要, API Layer 层可使用)
    */
    removeAll?: number;
}

declare interface IGetConversationListOption {
    type?: number;
    count?: number;
    startTime?: number;
    order?: 0 | 1;
}

declare interface IGetMsgOption {
    timestamp?: number;
    count?: number;
    order?: number;
}

export declare interface IJoinRTCRoomData extends IRTCUsers {
    token: string;
    sessionId: string;
}

export declare type IMessageListnenr = (message: IReceivedMessage) => void;

export declare interface IMetionedData {
    type?: MentionedType;
    userIdList?: string[];
    mentionedContent?: string;
}

/**
 * 导航信息数据就结构
 */
export declare interface INaviInfo {
    /**
     * Navi 数据请求响应码，200 为成功请求
     */
    code: number;
    /**
     * 获取 Navi 数据失败时的提示信息
     */
    errorMessage?: string;
    /**
     * 获取 Navi 数据失败时的请求 url 信息
     */
    url?: string;
    /**
     * 请求导航数据时使用的协议：http / https
     * @description 该字段为 SDK 内增加的字段，导航接口数据中不存在
     */
    protocol: 'http' | 'https';
    /**
     * 获取导航时使用的 userId
     * 小程序不走导航，拿不到 userId
     */
    userId?: string;
    /**
     * CMP 服务 Websocket 连接地址，包含域名与端口，不含 ws 或 wss 协议头
     * @example a.domain.com:443
     */
    server: string;
    /**
     * 备用 CMP 服务地址，包含域名与端口，不含 ws 或 wss 协议头，多个备用地址以 ',' 分割
     * @example a.domain.com:443,b.domain.com:443
     */
    backupServer?: string;
    /**
     * RTC 服务配置，其值可能为 null、无效字符串、有效 JSON 字符串
     * 1. 公有云未开通音视频时，值为 null
     * 2. 私有云无配置时为 `{ "strategy": 0 }`
     */
    voipCallInfo: string | null;
    /**
     * 聊天室 kv 存储开关
     * @todo 需确认详细有效值
     * @description 公有云独有配置
     */
    kvStorage: number;
    /**
     * HttpDNS 功能开关，在 web 端无效
     * @description 公有云独有配置
     */
    openHttpDNS: boolean;
    /**
     * 历史消息云存储功能开关
     * @description
     * 1. 公有云通过 `developer.rongcloud.cn` 管理后台 `单群聊消息云端存储` 功能开关进行配置
     * 2. 私有云默认为 `true`
     */
    historyMsg: boolean;
    /**
     * 聊天室历史消息开关
     * @description
     * 1. 私有云对聊天室功能支持有限，默认为 `false`
     * 2. TODO: 公有云配置待确认
     */
    chatroomMsg: boolean;
    /**
     * 文件服务器地址
     * @description
     * 1. 公有云下，该地址为七牛云服务器地址
     * 2. 私有云下，该地址为私有云自研文件服务器地址
     */
    uploadServer: string;
    /**
     * 实时位置共享配置，web 端无需处理
     */
    location: null | string;
    /**
     * 实时日志上传开关
     * @todo 需确认有效值及作用
     */
    monitor: number;
    /**
     * 是否允许加入多聊天室开关
     */
    joinMChrm: boolean;
    /**
     * 是否开启公众号功能：`0` 为未开启，`1` 为已开启
     */
    openMp: 0 | 1;
    /**
     * 是否开启用户级配置，若开启，需连接成功后立即拉取实时配置，0 | 1
     * @description
     * 配置来源:
     * 1. 导航
     * 2. 服务端实时下发
     * 已有配置字段:
     * 1. Lan. 推送使用的语言设置，用户端可自定义修改. Web 端未做设置, 只做接收
     * 2. ShPushSwit. 推送是否显示详情设置，用户端可自定义修改. Web 端未做设置, 只做接收
     * 3. MobPushSwit: Web/PC 在线，移动端不在线是否发送推送开关，用户端可自定义修改. Web 端未做设置, 只做接收
     * 4. OffMsgDur: 离线消息保存天数，设置天数不可大于App级对应配置，用户端可自定义修改. Web 端未做设置, 只做接收
     * 5. VoipInfo: 音视频相关配置，用户端不可自定义修改. 由服务端决定，与导航下发格式一致
     * @todo 需确认公有云与私有云区别
     */
    openUS: 0 | 1;
    /**
     * 群离线消息最大下发条数，`0` 为关闭
     * @description 公有云独有配合
     */
    grpMsgLimit: number;
    /**
     * 消息加密开关，0 为关闭
     * @todo
     * 1. 确定其控制的功能
     * 2. 确定 web 相关性
     */
    isFormatted: number;
    /**
     * GIF 动图大小限制，默认 2048 KB
     */
    gifSize: number;
    /**
     * 上传小视频时长限制，单位：秒
     * @description 公有云字段，即私有云配置中的 `uploadVideoTimeLimit`
     */
    videoTimes?: number;
    /**
     * 上传小视频时长限制，单位：秒
     * @description 私有云字段，即公有云配置中的 `videoTimes`
     */
    uploadVideoTimeLimit?: number;
    /**
     * 实时日志上传开关：`0` 为关闭，`1` 为开启
     */
    logSwitch: number;
    /**
     * 实时日志上传策略
     * @example `'{ "url": "logcollection.ronghub.com", "level": 1,"itv": 6, "times": 5 }'`
     */
    logPolicy: string;
    /**
     * 百度 BOS 存储服务地址
     * @description 公有云独有配置
     * @example `gz.bcebos.com`
     */
    bosAddr?: string;
    /**
     * @deprecated 已废弃
     */
    compDays: number;
    /**
     * @deprecated 已废弃
     */
    msgAck: unknown;
    /**
     * @deprecated 已废弃
     */
    activeServer: string;
    /**
     * @deprecated 已废弃
     */
    qnAddr: string;
    /**
     * @deprecated 已废弃
     */
    extkitSwitch: number;
    /**
     * @deprecated 已废弃
     */
    alone: boolean;
    /**
     * @deprecated 已废弃
     */
    voipServer: string;
    /**
     * 离线日志上报地址
     * @deprecated 已废弃
     */
    offlinelogserver: string;
    /**
     * 在线日志上报地址
     * @deprecated 已废弃
     */
    onlinelogserver?: string;
}

export declare const indexOf: (source: any[] | string, searchVal: any) => number;

export declare interface IPluginGenerator<API, InitOption> {
    /**
     * 只读插件标识
     */
    readonly tag: string;
    /**
     * 插件安装前的环境检测，通过返回 boolean 值确认插件是否可运行
     */
    verify(runtime: IRuntime): boolean;
    /**
     * 插件初始化
     * @param context 插件调用上下文，用于实现插件的消息注册、消息首发等
     * @param runtime 运行时实例，用于标识最终的运行时平台
     * @param options 初始化参数
     */
    setup(context: PluginContext, runtime: IRuntime, options: InitOption): API;
}

/**
 * 异步任务结果定义
 * @description
 * 通过 `Promise.resolve` 来处理预期内的异常，进而通过 Uncatch Promise Error 暴露预期外的异常
 */
export declare type IPromiseResult<T> = Promise<IAsyncRes<T>>;

/**
 * 从服务器拉取到的会话数据结构
 */
export declare interface IReceivedConversation {
    /**
     * 会话类型
     */
    conversationType: ConversationType;
    /**
     * 会话 Id
     * @description
     * 1. 当 `conversationType` 为 `ConversationType.GROUP` 时，该值为群组 Id
     * 1. 当 `conversationType` 为 `ConversationType.PRIVATE` 时，该值为对方用户 Id
     */
    targetId: string;
    /**
     * 当前会话的未读消息数
     */
    unreadMessageCount: number;
    /**
     * 会话中的最后一条消息
     */
    latestMessage: IReceivedMessage;
    /**
     * 是否包含 @ 自己的消息，此数据仅在 `conversationType` 为 `ConversationType.GROUP` 时有效
     */
    hasMentioned?: boolean;
    /**
     * 消息中的 @ 数据，仅在 `conversationType` 为 `ConversationType.GROUP` 时有效
     */
    mentionedInfo?: {
        /**
         * `@ 类型，其中 1 为 @ 所有人，2 为 @ 部分人`
         */
        type: 1 | 2;
        /**
         * 被 @ 的用户 Id 列表，仅在 `type` 为 `2` 时有效
         */
        userIdList: string[];
    } | null;
    /**
     * 会话免打扰状态
     * @description
     * 1. 已开启免打扰
     * 2. 未开启免打扰
     */
    notificationStatus: NotificationStatus;
    /**
     * 会话是否已置顶
     */
    isTop: boolean;
    /**
     * 会话中消息的最后未读时间
     */
    lastUnreadTime: number;
}

/**
 * 从服务端接收到的消息数据
 */
export declare interface IReceivedMessage {
    /**
     * 会话类型
     * * 1: 单聊
     * * 3: 群聊
     * * 4: 聊天室
     * * 5: 客服会话
     * * 6: 系统消息
     * * 7: 默认关注的公众号
     * * 8: 手动关注的公众号
     * * 9: RTCLib 房间
     */
    conversationType: ConversationType;
    /**
     * 会话 targetId
     */
    targetId: string;
    /**
     * 消息发送者的用户 Id
     */
    senderUserId: string;
    /**
     * 消息内容
     */
    content: any;
    /**
     * 消息结构名称，即消息类型
     * @example RC:TxtMsg
     */
    messageType: string;
    /**
     * 服务端存储的消息 Id
     */
    messageUId: string;
    /**
     * 消息方向是发出 or 收取
     */
    messageDirection: MessageDirection;
    /**
     * 是否为离线消息
     */
    isOffLineMessage: boolean;
    /**
     * 消息在服务器端的发送时间
     */
    sentTime: number;
    /**
     * 消息接收时间，该时间通过消息的 `sentTime` 值在本地进行计算得出，不推荐使用
     * @description 当 isOffLineMessage 为 true 时，该值无效
     */
    receivedTime: number;
    /**
     * 是否存储
     * @default true
     */
    isPersited: boolean;
    /**
     * 是否计数
     * @default true
     */
    isCounted: boolean;
    /**
     * 是否为 @ 消息
     */
    isMentioned: boolean;
    /**
     * 消息是否静默
     * @description 静默消息不会发送 Push 信息和本地通知提醒
     */
    disableNotification: boolean;
    /**
     * 是否是状态消息
     */
    isStatusMessage: boolean;
    /**
     * 是否支持消息扩展存储
    */
    canIncludeExpansion: boolean;
    /**
     * 消息携带的扩展存储
    */
    expansion: {
        [key: string]: any;
    } | null;
    /**
     * 消息接收状态
    */
    receivedStatus: number;
}

export declare interface IRemoveChatRoomEntryOption {
    /**
     * 属性名称, 支持英文字母、数字、+、=、-、_ 的组合方式, 最大长度 128 字符
     */
    key: string;
    /**
     * 删除成功后是否发送通知消息
     */
    isSendNotification?: boolean;
    /**
     * RC:chrmKVNotiMsg 消息中携带的附加信息
     */
    notificationExtra?: string;
}

export declare interface IRequest {
    url: string;
    /**
     * @default `HttpMethod.GET`
     */
    method?: HttpMethod;
    /**
     * 查询数据
     */
    query?: {
        [key: string]: string | number | null;
    };
    /**
     * Request Header 信息
     */
    headers?: {
        [key: string]: string;
    };
    /**
     * Request Body 数据
     */
    body?: Object | string;
    /**
     * 超时设置
     * @default 10 * 1000 毫秒
     */
    timeout?: number;
}

export declare interface IResponse {
    status: number;
    data?: string;
}

export declare type IRTCInnerListener = {
    message?: IMessageListnenr;
    status?: IConnectionStatusListener;
};

export declare interface IRTCRoomInfo {
    roomId: string;
    roomData: unknown[];
    userCount: number;
    list: unknown[];
}

export declare interface IRtcTokenData {
    rtcToken: string;
}

export declare interface IRTCUsers {
    users: {
        [userId: string]: {
            /**
             * 发布的资源数据，是一个 JSON 字符串，解析后为发布的资源列表
             */
            uris?: string;
        };
    };
}

/**
 * 平台运行时抽象
 */
export declare interface IRuntime {
    /**
     * 平台标识
     */
    tag: string;
    /**
     * 发送 http 请求
     * @param options
     */
    httpReq(options: IRequest): Promise<IResponse>;
    /**
     * 检测是否支持长连接
     */
    isSupportSocket(): boolean;
    /**
     * 是否使用导航
     */
    useNavi: boolean;
    /**
     * websocket 地址上附加的平台字段
     */
    connectPlatform: string;
    /**
     * websocket 地址上 apiVer 字段，代表代码是否来源于 uniapp
     */
    isFromUniapp: boolean;
    /**
     * 创建长连接实例
     */
    createWebSocket?(url: string, protocols?: string[]): IWebSocket;
    /**
     * 创建数据通道
     */
    createDataChannel(watcher: IDataChannelWatcher, connectType?: 'websocket' | 'comet'): ADataChannel;
    /**
     * 存储模块
     */
    localStorage: IStorage;
    /**
     * 在某些非浏览器平台，其等同于 localStorage
     */
    sessionStorage: IStorage;
}

/**
 * 检查参数是否为数组
 * 只做类型检查，不做长度检查
 * 如 UnitArray、BufferArray 等也属于数组
 * @param arr
 */
export declare const isArray: (arr: unknown) => boolean;

/**
 * 检查参数是否为 ArrayBuffer
 * @param arr
 */
export declare const isArrayBuffer: (arr: unknown) => boolean;

export declare interface ISendExMsgOptions {
    conversationType: ConversationType;
    targetId: string;
    /**
     * 消息 ID
    */
    messageUId: string;
    /**
     * 原始消息是否支持扩展的字段
    */
    canIncludeExpansion: boolean;
    /**
     * 删除的 keys
    */
    keys?: string[];
    /**
     * 扩展对象
    */
    expansion?: {
        [key: string]: string;
    };
    /**
     * 是否删除所有扩展
    */
    removeAll?: boolean;
    /**
     * 原始消息的扩展
    */
    originExpansion?: {
        [key: string]: string;
    } | null;
}

/**
 * 发送消息时的可选项信息
 */
export declare interface ISendMsgOptions {
    /**
     * 消息类型，即消息结构的 ObjectName
     */
    messageType: string;
    /**
     * 消息内容
     */
    content: {
        [key: string]: any;
    };
    /**
     * 是否存储
     * @description 只在发送未注册过的自定义消息时有效，否则使用注册时的配置
     */
    isPersited?: boolean;
    /**
     * 是否计数
     * @description 只在发送未注册过的自定义消息时有效，否则使用注册时的配置
     */
    isCounted?: boolean;
    /**
     * 是否是状态消息，一般为无需注册的自定义消息
     * @description
     * 1. 状态消息只有 pub，没有 ack 应答
     * 2. 状态消息默认不存储，不计数，`isPersited` 与 `isCounted` 配置将失效
     */
    isStatusMessage?: boolean;
    /**
     * 是否发送静默消息
     * @description
     * 当值为 `true` 时，服务器将不会发送 Push 信息，移动端也不会弹出本地通知提醒
     */
    disableNotification?: boolean;
    /**
     * Push 信息
     */
    pushContent?: string;
    /**
     * Push 通知携带的附加信息
     */
    pushData?: string;
    /**
     * 是否为 @ 消息，只当 conversationType 值为 `ConversationType.GROUP` 时有效
     */
    isMentioned?: boolean;
    /**
     * `@` 消息类型
     * @description `1: @ 所有人 2: @ 指定用户`
     */
    mentionedType?: 1 | 2;
    /**
     * 被 @ 的用户 Id 列表，当 `mentionedType` 值为 `1` 时，该值可为空
     */
    mentionedUserIdList?: string[];
    /**
     * 用于发送群定向消息，只当 conversationType 值为 `ConversationType.GROUP` 时有效
     */
    directionalUserIdList?: string[];
    /**
     * 当对方为 iOS 设备且未在线时，其将收到 Voip Push. 此配置对 Android 无影响
     */
    isVoipPush?: boolean;
    /**
     * 消息是否支持拓展内容
     */
    canIncludeExpansion?: boolean;
    /**
     * 消息拓展内容数据
     */
    expansion?: Object;
    /**
     * 黑/白名单
     * @todo 功能未知，需确认
     */
    isFilerWhiteBlacklist?: boolean;
}

declare interface IServerConversationStatus {
    conversationType: number;
    targetId: string;
    updatedTime?: number;
    notificationStatus?: number;
    isTop?: boolean;
    type?: number;
}

/**
 * 检查参数是否为函数
 * @param val
 */
export declare const isFunction: (val: any) => boolean;

/**
 * 检查参数是否为有效 http(s) 协议 url
 * @param value
 */
export declare const isHttpUrl: (value: any) => boolean;

export declare const isInclude: (source: string | any[], searchVal: any) => boolean;

/**
 * 判断对象里是否有某个值
*/
export declare const isInObject: (source: Object, searchVal: any) => boolean;

/**
 * 检查参数是否为 null
*/
export declare const isNull: (val: any) => boolean;

/**
 * 检查参数是否为 number 数据
 * @param value
 */
export declare const isNumber: (value: unknown) => boolean;

/**
 * 检查参数是否为对象
 * @param val
 */
export declare const isObject: (val: any) => boolean;

/**
 * 检查参数是否为字符串
 * 只做类型检查，不做长度检查，故当字符串长度为 0，结果依然为 true
 * @param str
 */
export declare const isString: (value: unknown) => boolean;

export declare interface IStorage {
    setItem(key: string, value: string): void;
    getItem(key: string): string | null;
    removeItem(key: string): void;
    clear(): void;
}

/**
 * 检查参数是否为undefined
 * @param val
 */
export declare const isUndefined: (val: any) => boolean;

export declare const isValidConversationType: (conversation: number) => boolean;

/**
 * 判断是否是一个有效的文件类型
 */
export declare const isValidFileType: (fileType: number) => boolean;

declare interface ISyncMsgArgs {
    inboxTime: number;
    sendboxTime: number;
}

export declare interface IUpdatedConversation {
    updatedItems: {
        [key: string]: {
            time: number;
            val: any;
        };
    };
    conversationType: number;
    targetId: string;
    latestMessage?: IReceivedMessage;
    unreadMessageCount?: number;
    hasMentioned?: boolean;
    mentionedInfo?: {
        /**
         * `@ 类型，其中 1 为 @ 所有人，2 为 @ 部分人`
         */
        type: 1 | 2;
        /**
         * 被 @ 的用户 Id 列表，仅在 `type` 为 `2` 时有效
         */
        userIdList: string[];
    };
    lastUnreadTime?: number;
    notificationStatus?: number;
    isTop?: boolean;
}

declare interface IUpdatedExpansion {
    expansion: {
        [key: string]: any;
    };
    messageUId: string;
}

export declare interface IUploadAuth {
    /**
     * 七牛 token 有效期
    */
    deadline: number;
    /**
     * 七牛上传 token
    */
    token: string;
    /**
     * 百度上传 token
    */
    bosToken: string;
    /**
     * 百度上传 header Date
    */
    bosDate: string;
    /**
     * 百度上传路径
    */
    path: string;
}

export declare interface IWatcher {
    message?: IMessageListnenr;
    connectionState?: IConnectionStatusListener;
    conversationState?: IConversationStateListener;
    chatroomState?: IChatroomListener;
    expansion?: IExpansionListener;
    /**
     * 为兼容老版本 RTCLib 与 CallLib 接收消息的方式，新版本消息走插件机制
     */
    rtcInnerWatcher?: IRTCInnerListener;
}

export declare interface IWebSocket {
    /**
     * 监听连接建立事件，此时 WebSocket 实例已准备好收发数据
     * @param callback
     */
    onOpen(callback: () => void): void;
    /**
     * 监听连接关闭事件
     * @param callback
     */
    onClose(callback: (code?: number, reason?: string) => void): void;
    /**
     * 监听接收服务器消息事件
     * @param callback
     */
    onMessage(callback: (data: string | ArrayBuffer) => void): void;
    /**
     * 监听链接错误事件
     * @param callback
     */
    onError(callback: (error: unknown) => void): void;
    /**
     * 向服务器发送数据
     * @param data
     */
    send(data: ArrayBuffer | string): void;
    /**
     * 关闭连接
     * @param code
     * @param reason
     */
    close(code?: number, reason?: string): void;
}

export declare interface KVString {
    [key: string]: string;
}

export declare enum LiveRole {
    /**
     * 主播身份
     */
    ANCHOR = 1,
    /**
     * 观众身份
     */
    AUDIENCE = 2
}

/**
 * 直播类型
 */
export declare enum LiveType {
    /**
     * 音视频直播
     */
    AUDIO_AND_VIDEO = 0,
    /**
     * 音频直播
     */
    AUDIO = 1
}

export declare class Logger {
    private readonly _tag;
    constructor(_tag: string);
    /**
     * 输出等级
     */
    private _outLevel;
    /**
     * 输出函数
     */
    private _stdout;
    /**
     * 默认输出函数
     * @param level
     * @param args
     */
    private _defaultStdout;
    private _out;
    /**
     * 设置默认输出等级及输出函数
     * @param outLevel
     * @param stdout
     */
    set(outLevel: LogLevel, stdout?: (level: LogLevel, ...args: any[]) => void): void;
    log: (level: LogLevel, ...args: any[]) => void;
    debug: (...args: any[]) => void;
    info: (...args: any[]) => void;
    warn: (...args: any[]) => void;
    error: (...args: any[]) => void;
}

export declare enum LogLevel {
    /**
     * 等同于 `LogLevel.DEBUG`
     */
    LOG = 0,
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3
}

/**
 * @deprecated
 * @param source
 * @param event
 */
export declare const map: (source: any[], event: Function) => any[];

/**
 * 群组 @ 类型
*/
export declare enum MentionedType {
    /**
     * 所有人
    */
    ALL = 1,
    /**
     * 部分人
    */
    SINGAL = 2
}

export declare enum MessageDirection {
    /**
     * 己方发送消息
     */
    SEND = 1,
    /**
     * 己方接收消息
     */
    RECEIVE = 2
}

/**
 * 内置消息类型
 */
export declare enum MessageType {
    /**
     * 文字消息
    */
    TextMessage = "RC:TxtMsg",
    /**
     * 语音消息
    */
    VOICE = "RC:VcMsg",
    /**
     * 高质量消息
    */
    HQ_VOICE = "RC:HQVCMsg",
    /**
     * 图片消息
    */
    IMAGE = "RC:ImgMsg",
    /**
     * GIF 消息
    */
    GIF = "RC:GIFMsg",
    /**
     * 图文消息
    */
    RICH_CONTENT = "RC:ImgTextMsg",
    /**
     * 位置消息
    */
    LOCATION = "RC:LBSMsg",
    /**
     * 文件消息
    */
    FILE = "RC:FileMsg",
    /**
     * 小视频消息
    */
    SIGHT = "RC:SightMsg",
    /**
     * 合并转发消息
    */
    COMBINE = "RC:CombineMsg",
    /**
     * 聊天室 KV 通知消息
    */
    CHRM_KV_NOTIFY = "RC:chrmKVNotiMsg",
    /**
     * 日志通知消息
    */
    LOG_COMMAND = "RC:LogCmdMsg",
    /**
     * 消息扩展
    */
    EXPANSION_NOTIFY = "RC:MsgExMsg",
    /**
     * 引用消息
    */
    REFERENCE = "RC:ReferenceMsg",
    /**
     * 撤回消息
    */
    RECALL = "RC:RcCmd"
}

/**
 * 检查参数是否为长度非 0 的数组
 * @param str
 */
export declare const notEmptyArray: (arr: any[]) => boolean;

/**
 * 检查对象不为空
 * @param val
*/
export declare const notEmptyObject: (val: Object) => boolean;

/**
 * 检查参数是否为长度非 0 的字符串
 * @param str
 */
export declare const notEmptyString: (str: string) => boolean;

export declare enum NotificationStatus {
    /**
     * 免打扰已开启
    */
    OPEN = 1,
    /**
     * 免打扰已关闭
    */
    CLOSE = 2
}

/**
 * 通信协议中 fixHeader 第一个字节中的 command 数据标识，用于判断操作类型
 * ```
 * fixHeader：command(4 bit) | dup(1 bit) | Qos(2 bit) | retain(1 bit)
 * ```
 */
declare enum OperationType {
    /** 私有云专用，解密协商指令 */
    SYMMETRIC = 0,
    /** 连接请求 */
    CONNECT = 1,
    /** 连接应答 */
    CONN_ACK = 2,
    /** 上行发送消息 */
    PUBLISH = 3,
    /** 上行发送消息的应答 */
    PUB_ACK = 4,
    /** 上行拉消息 */
    QUERY = 5,
    /** 上行拉消息的应答 */
    QUERY_ACK = 6,
    /** QueryConfirm */
    QUERY_CONFIRM = 7,
    SUBSCRIBE = 8,
    SUB_ACK = 9,
    UNSUBSCRIBE = 10,
    UNSUB_ACK = 11,
    PING_REQ = 12,
    PING_RESP = 13,
    /** 连接挂断 */
    DISCONNECT = 14,
    RESERVER2 = 15
}

export declare class PluginContext {
    protected readonly _context: APIContext;
    constructor(_context: APIContext);
    /**
     * 接收 IM 服务推送的消息，并通过返回 boolean 值决定此消息是否拦截
     * @param message
     * @returns 当返回值为 true，接收的消息将终止继续传递
     */
    onmessage?(message: IReceivedMessage): boolean;
    /**
     * 用户主动断开连接的事件通知
     */
    ondisconnect?(): void;
    /**
     * 接收 IM 连接状态变更通知
     * @param status
     */
    onconnectionstatechange?(status: ConnectionStatus): void;
    /**
     * IM 客户端销毁通知
     */
    ondestroy?(): void;
    /**
     * 获取 `@rongcloud/engine` 包版本
     */
    getCoreVersion(): string;
    /**
     * 获取当前运行中的 IMLib 版本号
     */
    getAPIVersion(): string;
    /**
     * 获取当前应用的 appkey
     */
    getAppkey(): string;
    /**
     * 获取当前已连接用户的 userId
     * 用户连接建立之前及 disconnect 之后，该方法返回 '' 值
     */
    getCurrentId(): string;
    /**
     * 获取当前连接状态
     */
    getConnectionStatus(): ConnectionStatus;
    /**
     * 发送消息
     */
    sendMessage(conversationType: ConversationType, targetId: string, options: ISendMsgOptions): IPromiseResult<IReceivedMessage>;
    /**
     * 消息注册
     * @description 消息注册需在应用初始化完成前进行
     * @param objectName 消息类型，如：RC:TxtMsg
     * @param isPersited 是否存储
     * @param isCounted 是否技术
     * @param searchProps 搜索字段，只在搭配协议栈使用时有效
     */
    registerMessageType(objectName: string, isPersited: boolean, isCounted: boolean, searchProps?: string[]): void;
}

/**
 * @description
 * 发消息, Server 给的 Ack 回执
 */
declare class PubAckReader extends RetryableReader {
    _name: string;
    status: number;
    date: number;
    data: any;
    millisecond: number;
    messageUId: string;
    timestamp: number;
    identifier: string;
    topic: string;
    targetId: string;
    readMessage(stream: RongStreamReader, length: number): {
        stream: RongStreamReader;
        length: number;
    };
}

declare class PublishReader extends RetryableReader {
    _name: string;
    topic: string;
    data: any;
    targetId: string;
    date: any;
    syncMsg: boolean;
    identifier: string;
    readMessage(stream: RongStreamReader, length: number): {
        stream: RongStreamReader;
        length: number;
    };
}

/**
 * @description
 * 发消息使用
 */
declare class PublishWriter extends RetryableWriter {
    _name: string;
    topic: string;
    data: any;
    targetId: string;
    date: any;
    syncMsg: boolean;
    identifier: string;
    constructor(topic: string, data: any, targetId: string);
    writeMessage(stream: RongStreamWriter): void;
}

/**
 * 通信协议中 fixHeader 第一个字节中的 Qos 数据标识
 * ```
 * fixHeader：command(4 bit) | dup(1 bit) | Qos(2 bit) | retain(1 bit)
 * ```
 */
declare enum QOS {
    AT_MOST_ONCE = 0,
    AT_LEAST_ONCE = 1,
    EXACTLY_ONCE = 2,
    DEFAULT = 3
}

/**
 * @description
 * Web 主动查询
 */
declare class QueryWriter extends RetryableWriter {
    name: string;
    topic: string;
    data: any;
    targetId: string;
    identifier: string;
    constructor(topic: string, data: any, targetId: string);
    writeMessage(stream: RongStreamWriter): void;
}

export declare class RCAssertError extends Error {
    constructor(message?: string);
}

export declare enum ReceivedStatus {
    /**
     * 已读
    */
    READ = 1,
    /**
     * 已听
    */
    LISTENED = 2,
    /**
     * 已下载
    */
    DOWNLOADED = 4,
    /**
     * 该消息已经被其他登录的多端收取过。( 即该消息已经被其他端收取过后。当前端才登录，并重新拉取了这条消息。客户可以通过这个状态更新 UI，比如不再提示 )
    */
    RETRIEVED = 8,
    /**
     * 未读
    */
    UNREAD = 0
}

declare class RetryableReader extends BaseReader {
    messageId: number;
    readMessage(stream: RongStreamReader, length: number): {
        stream: RongStreamReader;
        length: number;
    };
}

declare class RetryableWriter extends BaseWriter {
    messageId: number;
    writeMessage(stream: RongStreamWriter): void;
}

/**
 * @description
 * 融云读取二进制数据
*/
declare class RongStreamReader {
    private _pool;
    private _position;
    private _poolLen;
    constructor(arr: Uint8Array);
    check(): boolean;
    /**
     * 读 4 位
     */
    readInt(): number;
    /**
     * 读 8 位
     */
    readLong(): number;
    /**
     * 读 1 位
     */
    readByte(): number;
    /**
     * 获取数据
     */
    readUTF(): string;
    /**
     * 读剩余的所有值
     */
    readAll(): Uint8Array;
}

/**
 * @description
 * 融云写入二进制数据
*/
declare class RongStreamWriter {
    private _pool;
    private _position;
    private _writen;
    /**
     * 写入缓存区, writen 值往后移
     */
    write(byte: number): number;
    writeArr(byte: Array<number>): number[];
    writeUTF(str: string): void;
    getBytesArray(): Array<number>;
}

export declare enum RTCApiType {
    ROOM = 1,
    PERSON = 2
}

/**
 * 音视频模式
 */
export declare enum RTCMode {
    /**
     * 普通音视频模式
     */
    RTC = 0,
    /**
     * 直播模式
     */
    LIVE = 2
}

export declare class RTCPluginContext extends PluginContext {
    /**
     * 获取当前的导航数据
     */
    getNaviInfo(): INaviInfo | null;
    /**
     * 加入 RTC 房间
     * @todo 需确认 `broadcastType` 参数的作用与有效值
     * @param roomId
     * @param mode 房间模式：直播 or 会议
     * @param broadcastType
     */
    joinRTCRoom(roomId: string, mode: RTCMode, broadcastType?: number): IPromiseResult<IJoinRTCRoomData>;
    quitRTCRoom(roomId: string): Promise<ErrorCode>;
    rtcPing(roomId: string, mode: number, broadcastType?: number): Promise<ErrorCode>;
    getRTCRoomInfo(roomId: string): IPromiseResult<IRTCRoomInfo>;
    getRTCUserInfoList(roomId: string): IPromiseResult<IRTCUsers>;
    getRTCUserInfo(roomId: string): IPromiseResult<unknown>;
    setRTCUserInfo(roomId: string, key: string, value: string): Promise<ErrorCode>;
    removeRTCUserInfo(roomId: string, keys: string[]): Promise<ErrorCode>;
    setRTCData(roomId: string, key: string, value: string, isInner: boolean, apiType: RTCApiType, message?: any): Promise<ErrorCode>;
    /**
     * @param - roomId
     * @param - message 向前兼容的消息数据，以兼容旧版本 SDK，即增量数据，如：
     * ```
     * JSON.stringify({
     *  name: 'RCRTC:PublishResource',
     *  content: {
     *  }
     * })
     * ```
     * @param - valueInfo 全量资源数据
     * @param - 全量 URI 消息名，即 `RCRTC:TotalContentResources`
     */
    setRTCTotalRes(roomId: string, 
    /**
     * 向旧版本 RTCLib 兼容的消息数据
     */
    message: {
        /**
         * 消息名称，如 'RCRTC:PublishResource'
         */
        name: string;
        /**
         * 消息内容，是一个 JSON 字符串，包含 uris, ignore 两个属性
         */
        content: string;
    }, valueInfo: string, objectName: string): Promise<ErrorCode>;
    getRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType): IPromiseResult<KVString>;
    removeRTCData(roomId: string, keys: string[], isInner: boolean, apiType: RTCApiType, message: Object): Promise<ErrorCode>;
    setRTCOutData(roomId: string, rtcData: unknown, type: number, message: unknown): Promise<ErrorCode>;
    getRTCOutData(roomId: string, userIds: string[]): IPromiseResult<unknown>;
    getRTCToken(roomId: string, mode: number, broadcastType?: number): IPromiseResult<IRtcTokenData>;
    setRTCState(roomId: string, report: string): Promise<ErrorCode>;
    getRTCUserList(roomId: string): IPromiseResult<IRTCUsers>;
}

declare class Todo extends Error {
    constructor(message: string);
}

export declare const todo: (message: string) => Todo;

/**
 * 参数校验，该方法用于对业务层入参数据检查，与 `assert` 函数不同的是其返回 boolean 值而非直接抛出异常
 * @description
 * 1. 必填参数，value 需符合 validator 验证规，否则抛出异常
 * 2. 非必填参数，value 可为 undefined | null 或符合 validator 规则
 * @param key 字段名，仅用于验证失败时给出提示信息
 * @param value 待验证的值
 * @param validator 期望类型或校验规则函数，若使用规则函数
 * @param required 是否为必填参数，默认为 `false`
 */
export declare const validate: (key: string, value: any, validator: AssertRules | ((value: any) => boolean), required?: boolean) => boolean;

/**
 * @todo 迁移中的 DataCodec 模块导致数据通道不够独立，与 xhr-polling 通信可能会有耦合，后续需解耦
 * @description
 * 1. 基于 WebSocket 协议建立数据通道，实现数据收发
 * 2. 基于 Protobuf 进行数据编解码
 */
export declare class WebSocketChannel extends ADataChannel {
    private _runtime;
    private _socket;
    private _pingResolve?;
    /**
     * 本端发送消息时等待接收 PubAck 的 Promise.resolve 函数
     */
    private _messageIds;
    /**
     * 接收多端同步消息时，等待 PubAck 的 Promise.resolve 函数
     */
    private _syncMessageIds;
    connectedTime: number;
    userId: string;
    constructor(_runtime: IRuntime, watcher: IDataChannelWatcher);
    /**
     * 建立 websocket 连接
     * @param appkey
     * @param token
     * @param hosts
     * @param protocol
     * @param apiVersion - apiVersion 需符合 `/\d+(\.\d+){2}/` 规则
     */
    connect(appkey: string, token: string, hosts: string[], protocol: 'http' | 'https', apiVersion: string): Promise<ErrorCode>;
    /**
     * 当前累计心跳超时次数
     */
    private _failedCount;
    /**
     * 允许连续 PING 超时次数，次数内不主动关闭连接
     */
    private readonly ALLOW_FAILED_TIMES;
    private _checkAlive;
    private _onReceiveSignal;
    sendOnly(writer: BaseWriter): void;
    /**
     * 有效值 0 - 65535，超出 65535 位数超长溢出
     */
    private _idCount;
    private _generateMessageId;
    send(writer: QueryWriter | PublishWriter, respPBName?: string, option?: any, timeout?: number): Promise<IAsyncRes>;
    close(): void;
}

export { }
